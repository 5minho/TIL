#### 문제
https://leetcode.com/problems/queue-reconstruction-by-height/

#### 해결
문제를 읽고 뭔가 생각난 아이디어는

```
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

-> 정렬

[[4,4], [5,0], [5,2], [6,1], [7,0], [7,1]]
```

이렇게 정렬을 하고 `삽입 정렬` 구현 처럼 각 인덱스의 아이템이 들어갈 자리를 찾고 swap 해주면 되지 않을까 생각했음.

하지만 이런식으로 구현한다면 아이템이 들어갈 자리를 찾기 위해 루프를 앞에서 부터 한번 더 돌아햐 하므로 배우 비효율적임

생각이 안나서 아이디어 들을 찾아봤는데 그 중 제일 괜찮았던거는

```
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

-> 정렬 방식을 바꿔서 정렬하고 item[0] 으로 묶었음 

[[7,0], [7,1],
 [6,1],
 [5,0], [5,2],
 [4,4]]
```

이렇게 정렬 하고 앞에서 부터 차근차근 자기 자리를 찾는 것임, 단 자신의 뒤에 있는 아이템들은 상관하지 말고

[[7,0], [7,1], [6,1] ...] [7,0], [7,1] 은 자기 자신자리가 맞음 근데 [6,1] 의 자리는 6 보다 크거나 같은 숫자가 앞에 1개 있어야 함

그래서 그냥 인덱스 1 의 자리로 보내고 원래 있던 배열을 뒤로 밀면 됨 (미리 item[0] 의 내림차순으로 정렬했기 때문에 자연스럽게 item[0] 이 크면 뒤로 밀림)

[[7,0], [6,1], [7,1] ...]

이렇게 루프를 한번만 돌고 자기 자리를 찾을 수 있음

결국 item[0] 내림차순 정렬 item[1] 은 오름차순 정렬을 한다음, item[1] 의 위치에 삽입해주면 됨
