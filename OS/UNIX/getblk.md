### 알고리즘 getblk

#### 입력 : 파일 시스템 번호, 블럭 번호
#### 출력 : 블럭에 사용될 수 있는 잠겨있는(locked) 버퍼

```
while(버퍼가 발견되지 않는 동안)
{
  if(해쉬 큐에 블럭이 있으면)
  {
    if(버퍼가 사용중이면) // 시나리오 5
    {
      sleep(버퍼가 자유화 될때 까지)
      continue;
    }
    버퍼를 사용중이라고 표시 // 시나리오 1
    버퍼를 자유리스트에서 제거
    해당 버퍼 리턴
  }

  else /* 해쉬 큐에 블럭이 없음 */
  {
    if(자유 리스트상에 버퍼가 없으면) // 시나리오 4
    {
      sleep(임의의 버퍼가 자유화 될때 까지)
      continue
    }
    버퍼를 자유 리스트에서 제거 // 시나리오 2
    if(버퍼가 지연쓰기로 표시된 경우) // 시나리오 3
    {
      디스크에 버퍼를 비동기적으로 씀
      continue
    }
    버퍼를 이전 해쉬 큐에서 제거 // 장치 블럭 번호가 바뀌었으므로,
    버퍼를 새로운 해쉬 큐에 넣음 // 적절한 해쉬 큐의 변화가 필요할 것이다.
    해당 버퍼 리턴
  }
}

```


커널이 한 디스크 블럭을 위한 버퍼를 할당하기 위해 getblk 에서 따르게 될 5가니 전형적인 시나리오

1. 커널이 해쉬 큐에서 그 블럭을 발견하고, 그 버퍼가 자유이다.
2. 커널이 해쉬 큐 상에서 그 블럭을 발견하지 못하여 자유 리스트로부터 버퍼를 할당한다.
3. 커널이 해쉬 큐 상에서 그 블럭을 발견하지 못하여 자유 리스트로부터 버퍼 하나를 할당하려 할 때(시나리오 2 처럼), 자유 리스트상의 버퍼가 "지연쓰기"로 표기되어 있다. 커널은 그 "지연쓰기" 버퍼를 반드시 디스크에 써야하며, 다른 버퍼를 할당해야 한다.
4. 커널은 해쉬 큐 상에서 그 블럭을 발견하지 못하였으며, 버퍼의 자유 리스트가 비어 있다.
5. 커널이 해쉬 큐 상에서 그 블럭을 발견하였으나, 그 버퍼는 현재 사용중이다.
