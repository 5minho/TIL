### 트랜잭션(transaction)
일련의 SQL 명령들이 모두 함께 성공적으로 실행되든가 아니면 전혀 실행되지 않도록 하는 경계를 정의한다. (많이 드는 예는 은행송금이 있다.)
일련의 연산들이 모두 함께 수행되거나, 또는 아예 수행되지 않아야 한다는 것이 트랜잭션의 본질이다.

예를 들어서

```SQL
begin;
delete from foods;
rollback;
select count(*) from foods;
```
> 412

foods 의 모든 행을 지우고 rollback을 해서 삭제 이전의 상태로 되돌려 놓았다. (select 쿼리에서 아무것도 변경되지 않음)

SQLite는 모든 SQL명령을 자신의 트랜잭션 하에 실행된다. 무슨 말이냐면 begin ... commit / rollback 의 형태로 트랜잭션의 범위를 정의하지 않으면 개별적인 SQL 명령을 begin ... commit / rollback으로 둘러싸서 실행한다.

만약 성공적으로 명령이 실행된다면 commit 되고, 오류가 발생한다면 rollback된다.

### 락(lock)

데이터베이스의 트랜잭션과 락은 밀접한 관련이 있다. 한 세션이 데이터베이스에 쓰고 있을 때 다른 모든 세션들에 락을 걸어 동시성 문제를 해결한다. SQLite는 DB에 쓰는 세션에서 실제로 쓰기 직전까지 최대한 락을 보류 시켜 다른 세션의 기다림을 최소화 한다.

> SQLite 3.7.0 버젼 부터 WAL(Write-Ahead Logging, 선 로그법)을 사용해서 트랜잭션과 락킹의 처리 방법이 달라졌다고 한다.

SQLite에는 다섯 개의 락킹 상태가 있고, 각 데이터베이스 세션은 어떤 시점에서든 한 가지 상태만 될 수 있다. 또한 unlocked 상태를 제외하고 상응하는 락이 하나 있다.

* unlocked : 어떤 세션도 데이터베이스로부터 데이터를 액세스 하지 않는 상태

* shared : 데이터베이스로부터 데이터를 읽는 세션은 shared 락을 획득해야 한다. shared 락은 어떤 시점에서든 여러 개의 세션이 데이터 베이스를 읽을 수 있다. 이때는 어떤 세션도 데이터베이스에 쓸 수 없다.

* reserved : 데이터베이스에 쓰기 위해 획득해야 하기 위해 획득해야 하는 락, 어느 시점이든 하나의 reserved 락만 유지될 수 있다. shared 락을 갖는 다른 세션들을 방해하지 않는다.  reserved 락을 획득하면 데이터 변경을 할 수 있지만, 변경 내역은 메모리에 캐쉬되고 디스크에는 써지지 않는다.

* pending : reserved 락을 가진 시점에서 변경내역(또는 트랜잭션)을 커밋하려면 reserved 락을 exclusive 락으로 높여야 함. reserved -> pending 락으로 변경하고, 다른 shared 세션들이 작업을 종료하고 락을 해제하기 기다린다. 이때는 다른 세션이 새로운 shared 락을 획득할 수 없게 한다.

* exclusive : 모든 shared 락들이 해제 됐을때, pending 락을 가진 세션이 exclusive 락으로 바뀔 수 있고, 이때 부터 자유롭게 데이터베이스를 변경 할 수 있다 reserved 락을 획득한 부터 메모리에 캐시했던 변경 내역들을 데이터베이스 파일에 쓸 수 있다.
